diff --git a/README.md b/README.md
index 22c7745..f59f7bc 100644
--- a/README.md
+++ b/README.md
@@ -26,8 +26,9 @@ For now, you can only log in, save the session, and create a post. Other functio
 
 ```python 
 from x_lolo.session import Session
-new_session = Session()
-new_session.login("username", "password", save_session_to="session_data.yaml")
+new_session = Session(load_from="session_data.yaml")
 
-new_session.post_text("cr7 is the goat")
+post = new_session.add_post("here is a post")
+
+print(post.__dict__)
 ```
diff --git a/diff.diff b/diff.diff
new file mode 100644
index 0000000..338d633
--- /dev/null
+++ b/diff.diff
@@ -0,0 +1,104 @@
+diff --git a/.gitignore b/.gitignore
+index 3d88c94..eeb7ee8 100644
+--- a/.gitignore
++++ b/.gitignore
+@@ -3,4 +3,5 @@ main.py
+ __pycache__/
+ *.py[cod]
+ *$py.class
+-note
+\ No newline at end of file
++note
++diff
+\ No newline at end of file
+diff --git a/x_lolo/post.py b/x_lolo/post.py
+index 1339ddf..b0432e2 100644
+--- a/x_lolo/post.py
++++ b/x_lolo/post.py
+@@ -1,12 +1,12 @@
+-from .session import Session
+-from datetime import date as Date
++# from .session import Session
++from datetime import date as Date, datetime
+ 
+ 
+ class Post:
+-    def __init__(self, linked_session: Session):
+-        self.id: int | None = None
++    def __init__(self, linked_session):
++        self.id: str | None = None
+         self.owner_username: str | None = None
+-        self.owner_user_id: int | None = None
++        self.owner_user_id: str | None = None
+         self.linked_session = linked_session
+         self.creation_date: Date | None = None
+         self.like: int | None = None
+@@ -30,3 +30,21 @@ class Post:
+     def share(self):
+         # TODO
+         return
++
++    def load_by_creation_result(self, result):
++        try:
++            result = result["data"]["create_tweet"]["tweet_results"]["result"]
++            self.id = result["rest_id"]
++            self.creation_date = datetime.strptime(
++                result["legacy"]["created_at"], '%a %b %d %H:%M:%S %z %Y')
++            self.like = 0
++            self.view = 0
++            self.repost = 0
++            self.comment_count = 0
++            self.owner_user_id= self.linked_session.user_id 
++            self.text_content = result["legacy"]["full_text"]
++            result = result ["core"]["user_results"]["result"]
++            self.owner_username  = result["legacy"]["screen_name"]
++        except Exception :
++            raise Exception("Error func : load_by_creation_result ")
++        
+diff --git a/x_lolo/session.py b/x_lolo/session.py
+index 7424a5f..79e177f 100644
+--- a/x_lolo/session.py
++++ b/x_lolo/session.py
+@@ -6,6 +6,7 @@ from pathlib import Path
+ from typing import Dict, Any
+ from .request_payload_and_headers import TEXT_POST_REQUEST_COMPONENTS
+ import requests
++from .post import Post
+ 
+ 
+ class Session:
+@@ -38,7 +39,7 @@ class Session:
+             "x_guest_token": session.x_guest_token,
+             "flow_token": session.flow_token,
+             "x_csrf_token": session.x_csrf_token,
+-            "user_id": session.user_id 
++            "user_id": session.user_id
+         }
+ 
+         file_path = Path(filename)
+@@ -63,12 +64,19 @@ class Session:
+ 
+         return self
+ 
+-    def post_text(self, text):
++    def add_post(self, text: str, media_url: str | None = None) -> Post:
++        # TODO: handle media upload
++
+         response = requests.post(
+             url=TEXT_POST_REQUEST_COMPONENTS["url"], headers=TEXT_POST_REQUEST_COMPONENTS["headers"](self), json=TEXT_POST_REQUEST_COMPONENTS["payload"](text))
+-        if response.status_code!= 200:
++        if response.status_code != 200:
+             raise Exception(
+                 f"Error: {response.text}. Status code: {response.status_code}")
+-        response = response.json()
+-        if "errors" in response:
+-            raise Exception(f"X_API_ERROR_MESSAGE: {response['errors']}")
+\ No newline at end of file
++        response_json = response.json()
++        if "errors" in response_json:
++            print(f"X_API_ERROR_MESSAGE: {response_json['errors']}")
++            return None
++
++        new_post = Post(self)
++        new_post.load_by_creation_result(response_json)
++        return new_post
diff --git a/x_lolo/post.py b/x_lolo/post.py
index b0432e2..2d77728 100644
--- a/x_lolo/post.py
+++ b/x_lolo/post.py
@@ -1,9 +1,40 @@
-# from .session import Session
 from datetime import date as Date, datetime
 
 
 class Post:
+    """
+    Represents a post (tweet) on the X (formerly Twitter) platform.
+
+    This class encapsulates the data and functionality related to a single post.
+    It includes attributes for various post properties and methods for interacting
+    with the post.
+
+    Attributes:
+        id (str | None): The unique identifier of the post.
+        owner_username (str | None): The username of the post's author.
+        owner_user_id (str | None): The user ID of the post's author.
+        linked_session: The session object associated with this post.
+        creation_date (Date | None): The date the post was created.
+        like (int | None): The number of likes on the post.
+        text_content (str | None): The text content of the post.
+        comment_count (int | None): The number of comments on the post.
+        view (int | None): The number of views on the post.
+        repost (int | None): The number of reposts on the post.
+
+    Methods:
+        __init__: Initializes a new Post object.
+        load_by_creation_result: Loads post data from a creation result.
+    """
+
     def __init__(self, linked_session):
+        """
+            Initializes a new Post object.
+
+            This method sets up a new Post instance with default values for all attributes.
+            It also stores a reference to the linked session object.
+
+            :param linked_session: The session object associated with this post.
+            """
         self.id: str | None = None
         self.owner_username: str | None = None
         self.owner_user_id: str | None = None
@@ -15,6 +46,48 @@ class Post:
         self.view: int | None = None
         self.repost: int | None = None
 
+    def load_by_creation_result(self, result):
+        """
+        Loads post data from a creation result.
+
+        This method populates the Post object's attributes with data from a tweet creation result.
+        It extracts information such as the post ID, creation date, content, and author details.
+
+        :param result: The creation result data from the API.
+        :raises Exception: If there's a potential change in the API structure.
+        """
+        try:
+            # Extract the tweet result from the API response
+            result = result["data"]["create_tweet"]["tweet_results"]["result"]
+
+            # Set the post ID
+            self.id = result["rest_id"]
+
+            # Parse and set the creation date
+            self.creation_date = datetime.strptime(
+                result["legacy"]["created_at"], '%a %b %d %H:%M:%S %z %Y')
+
+            # Initialize engagement metrics (likes, views, reposts, comments)
+            self.like = 0
+            self.view = 0
+            self.repost = 0
+            self.comment_count = 0
+
+            # Set the owner's user ID from the linked session
+            self.owner_user_id = self.linked_session.user_id
+
+            # Set the post content
+            self.text_content = result["legacy"]["full_text"]
+
+            # Extract the author's username
+            result = result["core"]["user_results"]["result"]
+            self.owner_username = result["legacy"]["screen_name"]
+        except Exception:
+            # Raise an exception if there's a potential change in the API structure
+            raise Exception(
+                "Potential change on the API. Hint: func:`load_by_creation_result`")
+
+    # Non-implemented methods (not included in the class comment)
     def like(self):
         # TODO
         return
@@ -30,21 +103,3 @@ class Post:
     def share(self):
         # TODO
         return
-
-    def load_by_creation_result(self, result):
-        try:
-            result = result["data"]["create_tweet"]["tweet_results"]["result"]
-            self.id = result["rest_id"]
-            self.creation_date = datetime.strptime(
-                result["legacy"]["created_at"], '%a %b %d %H:%M:%S %z %Y')
-            self.like = 0
-            self.view = 0
-            self.repost = 0
-            self.comment_count = 0
-            self.owner_user_id= self.linked_session.user_id 
-            self.text_content = result["legacy"]["full_text"]
-            result = result ["core"]["user_results"]["result"]
-            self.owner_username  = result["legacy"]["screen_name"]
-        except Exception :
-            raise Exception("Error func : load_by_creation_result ")
-        
diff --git a/x_lolo/session.py b/x_lolo/session.py
index 79e177f..ff976cb 100644
--- a/x_lolo/session.py
+++ b/x_lolo/session.py
@@ -8,9 +8,21 @@ from .request_payload_and_headers import TEXT_POST_REQUEST_COMPONENTS
 import requests
 from .post import Post
 
-
 class Session:
+    """
+    Represents a user session for interacting with the X (formerly Twitter) API.
+    
+    This class manages the state and operations necessary for authenticating and 
+    performing actions on behalf of a user.
+    """
+    
     def __init__(self, load_from: str | None = None):
+        """
+        Initializes a new session.
+        
+        If load_from is specified, loads session data from a YAML file.
+        Otherwise, initializes a new session with cookies and a guest token.
+        """
         if load_from:
             self.__load_from_yaml(load_from)
             return
@@ -20,20 +32,34 @@ class Session:
         return
 
     def login(self, username_email: str, password: str, save_session_to: str = None):
-        flow_token, att_cookie = auth_flows.get(
-            self.cookies, self.x_guest_token)
+        """
+        Performs the login process.
+        
+        :param username_email: The email or username
+        :param password: The password
+        :param save_session_to: Path to save the session to (optional)
+        """
+        flow_token, att_cookie = auth_flows.get(self.cookies, self.x_guest_token)
         self.flow_token = flow_token
         self.cookies.dict["att"] = att_cookie
         self.user_id = ""
-
+        
+        # Performs the necessary steps for login
         auth_flows.pass_next_link(self)
         auth_flows.submit_username(self, username_email)
         auth_flows.submit_password(self, password)
-
+        
+        # Saves the session if requested
         if save_session_to:
             self.__save_to_yaml(self, save_session_to)
 
     def __save_to_yaml(cls, session: 'Session', filename: str = "session_data.yaml") -> None:
+        """
+        Saves the session data to a YAML file.
+        
+        :param session: The session object to save
+        :param filename: The path to save the YAML file (default: "session_data.yaml")
+        """
         data: Dict[str, Any] = {
             "cookies": session.cookies.dict,
             "x_guest_token": session.x_guest_token,
@@ -41,42 +67,56 @@ class Session:
             "x_csrf_token": session.x_csrf_token,
             "user_id": session.user_id
         }
-
+        
         file_path = Path(filename)
         with file_path.open("w") as f:
             yaml.dump(data, f, default_flow_style=False)
-
+        
         print(f"Session data saved to {file_path}")
 
     def __load_from_yaml(self, filename: str = "session_data.yaml") -> 'Session':
+        """
+        Loads session data from a YAML file.
+        
+        :param filename: The path to the YAML file (default: "session_data.yaml")
+        :return: The loaded Session object
+        """
         file_path = Path(filename)
         if not file_path.exists():
             raise FileNotFoundError(f"File {filename} not found")
-
+        
         with file_path.open("r") as f:
             data = yaml.safe_load(f)
-
+        
         self.cookies = Cookie(data["cookies"])
         self.x_guest_token = data["x_guest_token"]
         self.flow_token = data["flow_token"]
         self.x_csrf_token = data["x_csrf_token"]
         self.user_id = data["user_id"]
-
+        
         return self
 
     def add_post(self, text: str, media_url: str | None = None) -> Post:
+        """
+        Adds a new post (tweet) to the session.
+        
+        :param text: The text content of the post
+        :param media_url: URL of the media to attach (optional)
+        :return: The created Post object
+        """
         # TODO: handle media upload
-
         response = requests.post(
-            url=TEXT_POST_REQUEST_COMPONENTS["url"], headers=TEXT_POST_REQUEST_COMPONENTS["headers"](self), json=TEXT_POST_REQUEST_COMPONENTS["payload"](text))
+            url=TEXT_POST_REQUEST_COMPONENTS["url"], 
+            headers=TEXT_POST_REQUEST_COMPONENTS["headers"](self), 
+            json=TEXT_POST_REQUEST_COMPONENTS["payload"](text)
+        )
         if response.status_code != 200:
-            raise Exception(
-                f"Error: {response.text}. Status code: {response.status_code}")
+            raise Exception(f"Error: {response.text}. Status code: {response.status_code}")
         response_json = response.json()
         if "errors" in response_json:
             print(f"X_API_ERROR_MESSAGE: {response_json['errors']}")
             return None
-
+        
         new_post = Post(self)
         new_post.load_by_creation_result(response_json)
-        return new_post
+        return new_post
\ No newline at end of file
